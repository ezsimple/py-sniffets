.env
--
KEYCLOAK_SERVER_URL=https://a1.mkeasy.kro.kr/auth
KEYCLOAK_REALM=MinoRealm
KEYCLOAK_CLIENT_ID=file-download-app
KEYCLOAK_CLIENT_SECRET=leiXXLa6GawOYzAH2aPRVwc4GM6J2Ncx

core.config.py
--
class Settings:
  KEYCLOAK_SERVER_URL = os.getenv("KEYCLOAK_SERVER_URL")
  KEYCLOAK_REALM = os.getenv("KEYCLOAK_REALM")
  KEYCLOAK_CLIENT_ID = os.getenv("KEYCLOAK_CLIENT_ID")
  KEYCLOAK_CLIENT_SECRET = os.getenv("KEYCLOAK_CLIENT_SECRET")

settings = Settings()

app.py
--
from core.config import settings
from keycloak import KeycloakOpenID
from fastapi.security import OAuth2PasswordBearer

keycloak_openid = KeycloakOpenID(server_url=settings.KEYCLOAK_SERVER_URL,
                                  client_id=settings.KEYCLOAK_CLIENT_ID,
                                  client_secret_key=settings.KEYCLOAK_CLIENT_SECRET,
                                  realm_name=settings.KEYCLOAK_REALM)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{PREFIX}/token")


@app.post(f"{PREFIX}/token")
async def login(request: Request, response: Response, form_data: OAuth2PasswordRequestForm = Depends()):
    try:
        access_token = keycloak_openid.token(form.username, form.password)
    except Exception as e:
        return JSONResponse(content={"message": "Incorrect username or password"}, status_code=status.HTTP_401_UNAUTHORIZED)

... 생략
==
요청사항. 
답변은 한글로 상세히 설명을 해줘.

app.py 에 코드를 완성해줘.
1. middleware 를 통해 keycloak 연동처리(예: refresh_token) 되게 해줘.
2. login(), logout() 을 keycloak 연동처리 되게 해줘.
3. 서버사이드 구현으로 cookie 를 이용할 수 있으면 해줘.
4. redirect url 기능에 대해서 왜? 언제? 사용하는지에 대해 구현 및 설명해줘.

--
답변:
from fastapi import FastAPI, Request, Response, Depends, status, Cookie
from fastapi.responses import JSONResponse, RedirectResponse
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from keycloak import KeycloakOpenID
import os

# 환경변수에서 설정값 로드
class Settings:
    KEYCLOAK_SERVER_URL = os.getenv("KEYCLOAK_SERVER_URL")
    KEYCLOAK_REALM = os.getenv("KEYCLOAK_REALM")
    KEYCLOAK_CLIENT_ID = os.getenv("KEYCLOAK_CLIENT_ID")
    KEYCLOAK_CLIENT_SECRET = os.getenv("KEYCLOAK_CLIENT_SECRET")

settings = Settings()

# FastAPI 애플리케이션 생성
app = FastAPI()

# Keycloak OpenID 객체 생성
keycloak_openid = KeycloakOpenID(
    server_url=settings.KEYCLOAK_SERVER_URL,
    client_id=settings.KEYCLOAK_CLIENT_ID,
    client_secret_key=settings.KEYCLOAK_CLIENT_SECRET,
    realm_name=settings.KEYCLOAK_REALM
)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token")

# Token 유효성 검사 함수
async def verify_token(token: str = Depends(oauth2_scheme)):
    try:
        user_info = keycloak_openid.userinfo(token)  # 토큰에서 사용자 정보 가져오기
        return user_info  # 사용자 정보를 반환
    except Exception:
        raise HTTPException(status_code=401, detail="Unauthorized")

# 보호된 경로 예시
@app.get("/protected")
async def protected_route(user_info: dict = Depends(verify_token)):
    return {"message": "이곳은 보호된 경로입니다.", "user_info": user_info}

# Middleware 설정: refresh_token을 통해 세션 유지
@app.middleware("http")
async def keycloak_middleware(request: Request, call_next):
    refresh_token = request.cookies.get("refresh_token")
    if refresh_token:
        try:
            new_tokens = keycloak_openid.refresh_token(refresh_token)
            response = await call_next(request)
            response.set_cookie(key="access_token", value=new_tokens['access_token'])
            return response
        except Exception:
            pass  # Refresh token이 유효하지 않은 경우 처리

    response = await call_next(request)
    return response


# 로그인 엔드포인트
@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    try:
        access_token = keycloak_openid.token(form_data.username, form_data.password)
        # 로그인 성공 시
        response = JSONResponse(content={"access_token": access_token['access_token']})
        response.set_cookie(key="access_token", value=access_token['access_token'], httponly=True, secure=True)
        response.set_cookie(key="refresh_token", value=access_token['refresh_token'], httponly=True, secure=True)
        return response
    except Exception as e:
        return JSONResponse(content={"message": "로그인 실패: 잘못된 사용자 이름 또는 비밀번호"}, status_code=status.HTTP_401_UNAUTHORIZED)


# 로그아웃 엔드포인트
@app.post("/logout")
async def logout(response: Response, access_token: str = Depends(oauth2_scheme)):
    try:
        # Keycloak에 로그아웃 요청
        access_token = request.cookies.get("access_token")
        keycloak_openid.logout(access_token)
        response.delete_cookie("access_token")
        response.delete_cookie("refresh_token")
        return JSONResponse(content={"message": "로그아웃 성공"}, status_code=status.HTTP_200_OK)
    except Exception as e:
        return JSONResponse(content={"message": "로그아웃 실패"}, status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)


# 리다이렉트 URL에 대한 설명: 필요성 및 사용 시기
@app.get("/redirect")
async def redirect_example():
    # 사용자가 인증 후 보낼 리다이렉트 URL
    return RedirectResponse(url="/some_path")



